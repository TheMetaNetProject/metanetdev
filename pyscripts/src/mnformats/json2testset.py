#!/usr/bin/env python
'''
Converts from MetaNet JSON to IARPA TestSet XML
Created on April 20, 2013
@jhong@ICSI.Berkeley.EDU
'''

import os
import sys
import argparse
import json
import codecs
import urllib2
import subprocess
from xml import sax
from jsonschema import validate
import xml.etree.ElementTree as et

IXSCHEMA = u'https://metaphor.icsi.berkeley.edu/metaphor/ixjschema.json'
M4SCHEMAFILE = "/u/metanet/tools/etc/m4detectSchema_11.xsd"

def main():
    """
    Main processing for testset2json
    """
    cmdline = process_command_line()

    # prepare XML
    METADNS = "http://www.iarpa.gov/Metaphor/DetectSchema"
    XSINS = "http://www.w3.org/2001/XMLSchema-instance"
    M4SCHEMA = 'http://www.iarpa.gov/Metaphor/DetectSchema m4detectSchema_11.xsd'

    et.register_namespace("metad", METADNS)
    et.register_namespace("xsi", XSINS)

    tsroot = et.Element('metad:TestSet');
    tsroot.set('xsi:schemaLocation', M4SCHEMA)
    tsroot.set('xmlns:metad', METADNS)
    tsroot.set('xmlns:xsi', XSINS)
    tsroot.set('testId', cmdline.testid)
    tscount = 0

    # Prep JSON validator
    schemapath = cmdline.schema
    if schemapath.startswith('http'):
        schema = json.load(urllib2.urlopen(schemapath), encoding="UTF-8")
    else:
        schema = json.load(file(schemapath), encoding="UTF-8")

    #
    # ITERATE THROUGH ALL JSON FILES
    #
    # textcounter is used just for autogenerating numbers to append
    # to autogenerated textids, e.g. EN001, EN002, etc.
    #
    textcounters = {}
    for infile in cmdline.infile:
        SingleTextMode = False
        textid = None

        # Check that json is valid.  If not, then die
        data = json.load(file(infile), encoding="UTF-8")
        if validate(data, schema) is None:
            print infile, "validates"
        else:
            print infile, "fails to validate"
            return 1

        lang = data['lang']

        # attemt to figure out id scheme
        # whether there is textid embedded in it
        if ('sentences' not in data) or (len(data['sentences']) < 1):
            print >> sys.stderr, infile, " has no sentences. skipping."
            continue
        if 'id' not in data['sentences'][0]:
            print >> sys.stderr, "Sentence 1 does not have an id. skipping", infile
            continue

        # Depending on the number of ID segments there are
        # all the sentences in this json file are either all part of one
        # text, or part of multiple texts
        idsegs = data['sentences'][0]['id'].split(":")
        if len(idsegs) == 1:
            SingleTextMode = True
            # if singletextmode, then allow for command line override
            if cmdline.textid:
                textid = cmdline.textid
            else:
                # no testid and no text 1, just id numbers
                if lang not in textcounter:
                    textcounter[lang] = 1
                textid = lang.upper() + "{0:03d}".format(textcounter[lang])
                textcounter[lang] += 1
        #
        # At this point, the relevant variables are:
        # textid - which is needed if SingleTextMode
        # SingleTextMode
        #
        # Below: create a hash table from textid to lists of sentences
        #
        texts = {}
        if SingleTextMode:
            # easy all the sentences go into one text element
            texts[textid] = data['sentences']
        else:
            # first index all sentences by text
            for i in range(0, len(data['sentences'])):
                sentel = data['sentences'][i]
                idsegs = sentel['id'].split(":")
                textid = idsegs[-2]
                # replace id with just the last part of id string
                sentel['id'] = idsegs[-1]
                if textid not in texts:
                    texts[textid] = []
                texts[textid].append(sentel)

        # Go through texts and generate ETs
        textslist = texts.keys()
        textslist.sort()
        for text in textslist:
            tscount += 1
            textEl = et.SubElement(tsroot, 'metad:Text')
            textEl.set('id', text)
            textEl.set('lang', lang)
            textEl.set('count', str(len(texts[text])))
            for sent in texts[text]:
                sentEl = et.SubElement(textEl, 'metad:S')
                sentEl.set('id', sent['id'].split(":")[-1])
                sentEl.text = sent['text']
    tsroot.set('count', str(tscount))

    # Write out XML file
    # write result file
    outfilename = cmdline.testid + ".xml"
    if cmdline.outputfile:
        outfilename = cmdline.outputfile

    procoutfilename = "proc." + outfilename

    tstree = et.ElementTree(tsroot)
    tstree.write(outfilename, encoding='UTF-8', xml_declaration=True)

    # USE xmllint to validate and pretty-print
    # copy out pretty printed file using xmllint
    procoutfile = codecs.open(procoutfilename, "w", encoding='utf-8')
    xmlcode = subprocess.call(['xmllint',
                               '--schema',
                               cmdline.xmlschema,
                               '--format', outfilename],
                              stdout=procoutfile)
    procoutfile.flush()
    os.remove(outfilename)
    os.rename(procoutfilename, outfilename)
    return xmlcode


def process_command_line():
    """
    Return a command line parser object
    """
    global IXSCHEMA, M4SCHEMAFILE
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description="Converts one or more MetaNet JSON format file(s)"\
        " to IARPA TestSet XML format.",
        epilog="Note: everything is assumed to be UTF-8. The script also"\
        " has a number of system dependencies.  It requires 'xmllint' for"\
        " XML validation and pretty-printing.  Note also that -s and -x"\
        " have system-dependent defaults.")

    # required (positional) args
    parser.add_argument("infile", help="MetaNet JSON format file",
                        nargs='+')

    # optional args
    parser.add_argument("-s", "--schema", help="JSON Schema file or URL to " \
                        "use for validation. Overrides the schema "\
                        "specified in the file iself.", default=IXSCHEMA)
    parser.add_argument("-x", "--xmlschema", help="m4detect XSD Schema file "\
                        "to use for validation of the output XML.",
                        default=M4SCHEMAFILE)
    parser.add_argument("-o", "--outputfile",
                        help="Path/name of output file. If not given, the "\
                        "script uses the basename of the input file and "\
                        "appends .xml")
    parser.add_argument("-t", "--testid",
                        help="Value to use for the testid attribute."\
                        " It will also be used for the filename if "\
                        "-o is not used.", required=True)

    cmdline = parser.parse_args()
    return cmdline

if __name__ == "__main__":
    status = main()
    sys.exit(status)
