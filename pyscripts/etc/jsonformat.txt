
MetaNet JSON Interchange format

At the top level the JSON data structure has the following attributes:

	encoding 	- should be UTF-8
	lang 		- one of en, es, fa, ru
	jsonschema 	- always https://metaphor.icsi.berkeley.edu/metaphor/ixjschema.json
	documents 	- an array of document headers
	sentences 	- an array of sentences

Except for documents and sentences, which are lists, the other attributes have
string values. The jsonschema listed can be used to validate the JSON files
using the 'jsonvalidate' command.  Note that many json files generated by our
system are compressed or have whitespace removed.  The 'ppjson' can be used to
pretty print them to standard out.

Below is a sample, which could be a json input file into our system:

{
    "encoding": "UTF-8",
    "jsonschema": "https://metaphor.icsi.berkeley.edu/metaphor/ixjschema.json",
    "lang": "en",
    "documents": [
        {
            "corpus": "CNC",
            "name": "CNC_A00",
            "provenance": "CNC_A00",
            "description": "A document in the CNC",
            "lang": "en",
            "size": 10000,
            "type": "news"
        },
        {
            "corpus": "CNC",
            "name": "CNC_A01",
            "provenance": "CNC_A01",
            "description": "Another document in the CNC",
            "lang": "en",
            "size": 10001,
            "type": "literature"
        }
   ],
   "sentences": [
        {
            "id": "CNC_A00:1",
            "idx": 0,
            "text": "Tackling poverty is important."
        },
        {
            "id": "CNC_A01:1",
            "idx": 1,
            "text": "Poverty kills millions every year."
        }
    ]
}

The document header structures are used to keep track of source information for the
sentences in the JSON.  Each item in the documents list should have the following
attributes:

	corpus 		- the corpus that the document came from, e.g. BNC or ENGW for
				  English Gigaword
	name 		- name to use to distinguish the document in our system from other
				  documents
	provenance 	- ideally a URI, or is not, some other string that uniquely
				  represents where it came from
	description - description of the document
	lang 		- used to override the lang at the top level in the case of single
				  JSON files with documents of differing languages.
	size 		- the number of sentences in the document
	type 		- genre or other type classification: usu. as provided by the source

Except for 'size', which requires an integer value, all of the attributes above
have string values.
	
Each sentence item in the sentences list must have the following attributes:

	id		- a string that uniquely identifies the sentence in our system
		  	  e.g. document_provenance:number or document_name:number
	idx 	- the index of that item in the sentences array.  (To retrieve neighbors
			  if needed)
	text 	- the text of the sentence
	
Additionally, the sentence may define other attributes:

	mtext	- a string used for search purposes (a processed version of text)
	word	- a list of words in the sentence, with word attributes
	dparse	- dependency parse
	lms		- a list of LMs extracted from the sentence

In principle, additional sentence-level attributes could be added to the JSON
for use by any individual processing module without interfering with the operation
of other modules provided there aren't namespace collisions.

Currently, for the word list, each item in the word list has the following
attributes:

	idx		- the index of the word in the array
	n 		- string value used by external systems to refer to the word (alternate
			  numbering)
	form 	- the word form
	lem 	- lemma
	pos 	- part of speech
	start 	- integer start position of the first character of the word in the
			  sentence
	end 	- integer position of the end of word in the sentence
	
Again, individual modules may add additional word-level attributes.

The dependency parse list has items which can have the following items.  Largely it
reflects the parse information generated by RASP.  All the attributes have string
values:

	grtype		- grammatical relation type
	grsubtype	- grammatical relation subtype (if there is one)
	head		- the head word (identified via the 'n' attribute in the word
				  lists above)
	dep			- the dep word (identified via the 'n' attribute in the word
				  lists above)
	initgrtype	- initial (pre-transformation--ack!) grammatical relation type

LMs in the lms list have the following attributes:

	name 		- name for displaying the LM
	target 		- a dict containing information about the target
	source 		- a dict containing information about the source
	cxn 		- name of the construction used to find the LM
	extractor 	- name of the extractor used to find the LM
	seed 		- the seed used by the seed based system to find the LM
		   		  set to None by the CMS, and NA by the LMS.
	score 		- floating point value indicating a scoring of the LM
	affect 		- integer between -5 and 5 indicating affect in terms of polarity
				  and intensity

The target and source dicts have similar structure and have the following attributes:

	form		- the target/source expression as it appears in the sentence
	mword		- the word/expression used to match it (CMS)
	wdomain		- the domain of the word/expression used to match it (CMS)
	rel			- the relation used to match the word (SBS)
	lemma		- the lemma of source or target expression
	schema		- the schema (from the wiki, if known)
	concept		- the IARPA concept the expression should link to (ABYSS)
	dimension	- for source only: the IARPA dimension within the source concept
				  (ABYSS.Exit)
	start		- start character position in the sentence
	end			- end character position in the sentence
	
Note that all the attributes above, except start and end, are string values.  Schemas,
concepts and subdimensions should be referred to by name.

The following is an example JSON, which could be the output of our system after all
parts have run, from metaphor extraction, to concept mapping, source dimension mapping,
and affect determination.

{
    "encoding": "UTF-8",
    "jsonschema": "https://metaphor.icsi.berkeley.edu/metaphor/ixjschema.json",
    "lang": "en",
    "documents": [
        {
            "corpus": "CNC",
            "name": "CNC_A00",
            "provenance": "CNC_A00",
            "description": "A document in the CNC",
            "lang": "en",
            "size": 10000,
            "type": "news"
        },
        {
            "corpus": "CNC",
            "name": "CNC_A01",
            "provenance": "CNC_A01",
            "description": "Another document in the CNC",
            "lang": "en",
            "size": 10001,
            "type": "literature"
        }
   ],
   "sentences": [
        {
            "id": "CNC_A00:1",
            "idx": 0,
            "text": "Tackling poverty is important.",
            "mtext": "Tackling=tackle=VBG=0 poverty=poverty=NN=1 is=be=VBZ=2 important=important=JJ=3 .=.=SENT=4",
            "word" : [
                {
                    "idx": 0,
                    "n": "1",
                    "form": "Tackling",
                    "lem" : "tackle",
                    "pos" : "VBG",
                    "start": 0,
                    "end": 8
                },
                {
                    "idx": 1,
                    "n": "2",
                    "form": "poverty",
                    "lem" : "poverty",
                    "pos" : "NN",
                    "start": 10,
                    "end": 17
                },
                {
                    "idx": 2,
                    "n": "3",
                    "form": "is",
                    "lem" : "be",
                    "pos" : "VBZ",
                    "start": 19,
                    "end": 21
                },
                {
                    "idx": 3,
                    "n": "4",
                    "form": "important",
                    "lem" : "important",
                    "pos" : "JJ",
                    "start": 23,
                    "end": 31
                },
                {
                    "idx": 4,
                    "n": "5",
                    "form": ".",
                    "lem" : ".",
                    "pos" : "SENT",
                    "start": 33,
                    "end": 34
                }
            ],
            "dparse": [
                {
                    "grtype": "ncsubj",
                    "head": "3",
                    "dep": "2",
                    "initgrtype": "_"
                },
                {
                    "grtype": "xcomp",
                    "head": "3",
                    "dep": "4"
                },
                {
                    "grtype": "ncsubj",
                    "head": "1",
                    "dep": "2",
                    "initgrtype": "_"
                },
                {
                    "grtype": "ncmod",
                    "head": "2",
                    "dep": "1"
                }                    
            ],
            "lms": [
                {
                    "name": "poverty tackle",
                    "extractor": "CMS",
                    "cxn": "@S@ @T@",
                    "score": 1001000.0,
                    "seed": "None",
                    "affect": -2,
                    "target": {
                        "form": "poverty",
                        "lemma": "poverty",
                        "mword": "poverty",
                        "rel": "None",
                        "start": 10,
                        "end": 17,
                        "wdomain": "POVERTY",
                        "schema": "Poverty",
                        "concept": "POVERTY"
                    },
                    "source": {
                        "form": "Tackling",
                        "lemma": "tackle",
                        "mword": "tackl(e|es|ed|ing)",
                        "rel": "None",
                        "start": 0,
                        "end": 8,
                        "wdomain": "POVERTY",
                        "schema": "Motion impediments",
                        "concept": "PHYSICAL_HARM",
                        "dimension": "PHYSICAL_HARM.Restraint"
                    }
                }
            ]
        }
    ]
}


